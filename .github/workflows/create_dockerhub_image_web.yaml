name: Build/Push Web Image to Docker Hub 

on:
  # push:
  #   branches:
  #     - main
  #   paths-ignore:
  #     - '.github/workflows/**'
  #     - 'README.md'
  workflow_dispatch:
    inputs:
      version_bump:
        description: "Version bump type ('none' for tag 'latest' only)"
        required: true
        type: choice
        options:
          - none
          - patch
          - minor
          - major
        default: "patch"
      push_on_test_failure:
        description: "Push image even if tests fail?"
        required: true
        type: choice
        options:
          - "no"
          - "yes"
        default: "yes"
      image_name:
        description: "Image name"
        required: true
        type: string
        default: "web"

jobs:
  # ============================================
  # SETUP CONFIGURATION
  # ============================================
  
  setup:
    name: Setup Configuration
    runs-on: ubuntu-latest
    outputs:
      version_bump: ${{ steps.config.outputs.version_bump }}
      push_on_test_failure: ${{ steps.config.outputs.push_on_test_failure }}
      image_name: ${{ steps.config.outputs.image_name }}
    steps:
      - name: Set Configuration
        id: config
        run: |
          # Use workflow_dispatch inputs or fallback to input defaults
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION_BUMP="${{ inputs.version_bump }}"
            PUSH_ON_FAILURE="${{ inputs.push_on_test_failure }}"
            IMAGE_NAME="${{ inputs.image_name }}"
          else
            VERSION_BUMP="patch"
            PUSH_ON_FAILURE="no"
            IMAGE_NAME="web"
          fi
          
          echo "version_bump=$VERSION_BUMP" >> $GITHUB_OUTPUT
          echo "push_on_test_failure=$PUSH_ON_FAILURE" >> $GITHUB_OUTPUT
          echo "image_name=$IMAGE_NAME" >> $GITHUB_OUTPUT
          
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "üìã Using workflow_dispatch inputs"
          else
            echo "üìã Using default configuration for push event"
          fi
          
          echo "‚úÖ Configuration set:"
          echo "  - Version bump: $VERSION_BUMP"
          echo "  - Push on test failure: $PUSH_ON_FAILURE"
          echo "  - Image name: $IMAGE_NAME"

  # ============================================
  # PRE-BUILD TESTS
  # ============================================
  
  lint:
    name: Lint Test
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install
      
      - name: Run ESLint
        run: |
          npm run lint 2>/dev/null || echo "‚ö†Ô∏è Lint not configured"

  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install
      
      - name: Run Unit Tests
        run: |
          npm test 2>/dev/null || echo "‚ö†Ô∏è Tests not configured"

  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install
      
      - name: Run Integration Tests
        run: |
          npm run test:integration 2>/dev/null || echo "‚ö†Ô∏è Integration tests not configured"

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install
      
      - name: Run npm audit
        run: npm audit --audit-level=moderate || true

  dockerfile-lint:
    name: Dockerfile Lint
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Lint Dockerfile
        uses: hadolint/hadolint-action@v3.1.0
        with:
          dockerfile: Dockerfile
          failure-threshold: warning

  # NEW: Dependency validation
  dependency-check:
    name: Dependency Validation
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Validate package.json
        run: |
          [ -f "package.json" ] || { echo "‚ùå package.json not found"; exit 1; }
          jq empty package.json 2>/dev/null || { echo "‚ùå Invalid JSON"; exit 1; }
      
      - name: Check for outdated dependencies
        run: |
          npm install
          npm outdated || echo "‚ö†Ô∏è Outdated dependencies"
      
      - name: Check for duplicate dependencies
        run: |
          npm dedupe --dry-run || echo "‚ö†Ô∏è Duplicate dependencies"

  # NEW: License compliance check
  license-check:
    name: License Compliance
    runs-on: ubuntu-latest
    continue-on-error: true
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: npm install
      
      - name: Install license-checker
        run: npm install -g license-checker
      
      - name: Check licenses (Summary)
        run: license-checker --summary
      
      - name: Check licenses (Detailed)
        run: |
          license-checker --json > licenses.json
          cat licenses.json
      
      - name: Check for prohibited licenses
        run: |
          PROHIBITED="GPL|AGPL|LGPL"
          if license-checker --json | jq -r '.[] | .licenses' | grep -iE "$PROHIBITED"; then
            echo "‚ö†Ô∏è Problematic licenses found (GPL family)"
            license-checker --json | jq -r 'to_entries[] | select(.value.licenses | test("GPL|AGPL|LGPL"; "i")) | "\(.key): \(.value.licenses)"'
          fi
      
      - name: Generate license report
        run: license-checker --csv > license-report.csv
      
      - name: Upload license report
        uses: actions/upload-artifact@v4
        with:
          name: license-report
          path: |
            NodeJSweb/licenses.json
            NodeJSweb/license-report.csv
          retention-days: 30

  # ============================================
  # BUILD IMAGE
  # ============================================
  
  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [setup, lint, unit-tests, integration-tests, security, dockerfile-lint, dependency-check, license-check]
    if: ${{ always() }}
    environment: dev
    permissions:
      contents: write
      packages: write
    outputs:
      image_tag: ${{ steps.version.outputs.tag }}
      image_name: ${{ steps.version.outputs.full_image_name }}
      local_image_name: ${{ needs.setup.outputs.image_name }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get latest version from Docker Hub
        id: get-version
        if: inputs.version_bump != 'none'
        run: |
          FULL_IMAGE_NAME="${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.setup.outputs.image_name }}"
          TAGS=$(curl -s "https://hub.docker.com/v2/repositories/$FULL_IMAGE_NAME/tags/?page_size=100" | jq -r '.results[].name' | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | sed 's/^v//' | sort -V | tail -1)
          
          if [ -z "$TAGS" ]; then
            LATEST_VERSION="0.0.0"
          else
            LATEST_VERSION="$TAGS"
          fi
          
          echo "latest_version=$LATEST_VERSION" >> $GITHUB_OUTPUT

      - name: Bump version
        id: bump
        if: inputs.version_bump != 'none'
        run: |
          LATEST_VERSION="${{ steps.get-version.outputs.latest_version }}"
          IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_VERSION"
          
          case "${{ needs.setup.outputs.version_bump }}" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Validate Docker Hub Username
        run: |
          if [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            echo "‚ùå ERROR: DOCKERHUB_USERNAME secret is not set!"
            echo "Please add the DOCKERHUB_USERNAME secret to your repository:"
            echo "Settings ‚Üí Secrets and variables ‚Üí Actions ‚Üí New repository secret"
            echo "Name: DOCKERHUB_USERNAME"
            echo "Value: Your Docker Hub username"
            exit 1
          fi
          echo "‚úÖ DOCKERHUB_USERNAME secret is set"

      - name: Set version tag and full image name
        id: version
        run: |
          DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
          IMAGE_NAME="${{ needs.setup.outputs.image_name }}"
          FULL_IMAGE_NAME="$DOCKERHUB_USER/$IMAGE_NAME"
          
          echo "full_image_name=$FULL_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Docker Hub image will be: $FULL_IMAGE_NAME"
          
          if [ "${{ needs.setup.outputs.version_bump }}" = "none" ]; then
            VERSION_TAG="latest"
          else
            VERSION_TAG="${{ steps.bump.outputs.new_version }}"
          fi
          echo "tag=$VERSION_TAG" >> $GITHUB_OUTPUT
          echo "Version tag: $VERSION_TAG"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Check Test Results
        run: |
          echo "Tests: Lint=${{ needs.lint.result }} Unit=${{ needs.unit-tests.result }}"
          echo "Integration Tests: ${{ needs.integration-tests.result }}"
          echo "Security: ${{ needs.security.result }}"
          echo "Dockerfile Lint: ${{ needs.dockerfile-lint.result }}"
          echo "Dependency Check: ${{ needs.dependency-check.result }}"
          echo "License Check: ${{ needs.license-check.result }}"
          echo "Push on failure: ${{ needs.setup.outputs.push_on_test_failure }}"
          
          if [ "${{ needs.setup.outputs.push_on_test_failure }}" = "yes" ]; then
            echo "‚ö†Ô∏è Building image despite test failures (push_on_test_failure=yes)"
          else
            echo "‚úÖ All tests passed, proceeding with build"
          fi

      - name: Build Docker Image
        run: |
          VERSION_TAG="${{ steps.version.outputs.tag }}"
          LOCAL_IMAGE_NAME="${{ needs.setup.outputs.image_name }}"
          
          docker build -t $LOCAL_IMAGE_NAME:$VERSION_TAG .
          echo "‚úÖ Built: $LOCAL_IMAGE_NAME:$VERSION_TAG"

      - name: Save Docker Image
        run: |
          VERSION_TAG="${{ steps.version.outputs.tag }}"
          LOCAL_IMAGE_NAME="${{ needs.setup.outputs.image_name }}"
          
          docker save $LOCAL_IMAGE_NAME:$VERSION_TAG | gzip > /tmp/docker-image.tar.gz

      - name: Upload Docker Image Artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/docker-image.tar.gz
          retention-days: 1

  # ============================================
  # POST-BUILD TESTS
  # ============================================

  # NEW: Vulnerability scan with Trivy
  test-image-vulnerabilities:
    name: Scan Image Vulnerabilities
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}'
          format: 'table'
          exit-code: '0'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL,HIGH'

  test-image-health:
    name: Test Image Health
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Test Health Endpoint
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          docker run -d --name health-test \
            -p 3000:3000 \
            -e DBUSER=testuser \
            -e DB=testdb \
            -e DBPASS=testpass \
            -e DBHOST=localhost \
            -e DBPORT=3306 \
            $IMAGE_URI
          
          sleep 5
          
          echo "Testing /health endpoint..."
          if curl -f http://localhost:3000/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ùå Health check failed"
            docker logs health-test
            exit 1
          fi
          
          docker stop health-test
          docker rm health-test

  test-image-startup:
    name: Test Image Startup
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Test Container Startup
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          docker run -d --name startup-test \
            -p 3001:3000 \
            -e DBUSER=testuser \
            -e DB=testdb \
            -e DBPASS=testpass \
            -e DBHOST=localhost \
            -e DBPORT=3306 \
            $IMAGE_URI
          
          sleep 5
          
          if docker ps | grep startup-test; then
            echo "‚úÖ Container started successfully"
          else
            echo "‚ùå Container failed to start"
            docker logs startup-test
            exit 1
          fi
          
          docker stop startup-test
          docker rm startup-test

  test-image-size:
    name: Test Image Size
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Check Image Size
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          IMAGE_SIZE=$(docker image inspect $IMAGE_URI --format='{{.Size}}')
          IMAGE_SIZE_MB=$((IMAGE_SIZE / 1024 / 1024))
          
          echo "Image size: ${IMAGE_SIZE_MB}MB"
          
          if [ $IMAGE_SIZE_MB -gt 500 ]; then
            echo "‚ö†Ô∏è Image is larger than 500MB"
          else
            echo "‚úÖ Image size is acceptable"
          fi

  # NEW: Port exposure test
  test-image-ports:
    name: Test Port Exposure
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Check Exposed Ports
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          EXPOSED_PORTS=$(docker image inspect $IMAGE_URI --format='{{json .Config.ExposedPorts}}')
          
          if echo "$EXPOSED_PORTS" | grep -q "3000"; then
            echo "‚úÖ Port 3000 is exposed"
          else
            echo "‚ùå Port 3000 is not exposed"
            exit 1
          fi

  # NEW: Environment variables test
  test-image-env-vars:
    name: Test Environment Variables
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Test with Missing Environment Variables
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          docker run -d --name env-test -p 3002:3000 $IMAGE_URI || true
          
          sleep 3
          
          # Check if container is still running or exited gracefully
          if docker ps -a | grep env-test | grep -q "Exited"; then
            echo "‚ö†Ô∏è Container exited (expected if env vars are required)"
            docker logs env-test
          else
            echo "‚úÖ Container handles missing env vars gracefully"
          fi
          
          docker stop env-test 2>/dev/null || true
          docker rm env-test 2>/dev/null || true

  # NEW: User permissions test
  test-image-security:
    name: Test Security (Non-root User)
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Check User Permissions
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          USER=$(docker image inspect $IMAGE_URI --format='{{.Config.User}}')
          
          if [ -z "$USER" ] || [ "$USER" = "root" ] || [ "$USER" = "0" ]; then
            echo "‚ö†Ô∏è Container runs as root user (security risk)"
          else
            echo "‚úÖ Container runs as non-root user: $USER"
          fi

  # NEW: Graceful shutdown test
  test-image-shutdown:
    name: Test Graceful Shutdown
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: ${{ inputs.push_on_test_failure == 'yes' }}
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Test SIGTERM Handling
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          docker run -d --name shutdown-test \
            -p 3003:3000 \
            -e DBUSER=testuser \
            -e DB=testdb \
            -e DBPASS=testpass \
            -e DBHOST=localhost \
            -e DBPORT=3306 \
            $IMAGE_URI
          
          sleep 3
          
          echo "Sending SIGTERM..."
          START_TIME=$(date +%s)
          docker stop -t 10 shutdown-test
          END_TIME=$(date +%s)
          SHUTDOWN_TIME=$((END_TIME - START_TIME))
          
          echo "Shutdown time: ${SHUTDOWN_TIME}s"
          
          if [ $SHUTDOWN_TIME -lt 10 ]; then
            echo "‚úÖ Container shut down gracefully in ${SHUTDOWN_TIME}s"
          else
            echo "‚ö†Ô∏è Container took full timeout (10s) to shutdown"
          fi
          
          docker rm shutdown-test

  # NEW: Layer analysis
  test-image-layers:
    name: Analyze Image Layers
    runs-on: ubuntu-latest
    needs: [setup, build-image]
    if: ${{ always() && needs.build-image.result == 'success' }}
    continue-on-error: true
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Analyze Image Layers
        run: |
          IMAGE_URI="${{ needs.build-image.outputs.local_image_name }}:${{ needs.build-image.outputs.image_tag }}"
          
          docker history $IMAGE_URI
          
          LAYER_COUNT=$(docker history $IMAGE_URI --format "{{.ID}}" | wc -l)
          echo "Total layers: $LAYER_COUNT"
          
          if [ $LAYER_COUNT -gt 20 ]; then
            echo "‚ö†Ô∏è Image has many layers ($LAYER_COUNT), consider optimization"
          else
            echo "‚úÖ Layer count is reasonable"
          fi

  # ============================================
  # ============================================
  # PUSH IMAGE
  # ============================================

  push-image:
    name: Push Docker Image
    runs-on: ubuntu-latest
    needs: [
      build-image, 
      test-image-vulnerabilities,
      test-image-health, 
      test-image-startup, 
      test-image-size,
      test-image-ports,
      test-image-env-vars,
      test-image-security,
      test-image-shutdown,
      test-image-layers
    ]
    if: ${{ always() && needs.build-image.result == 'success' && (inputs.push_on_test_failure == 'yes' || (needs.test-image-health.result == 'success' && needs.test-image-startup.result == 'success' && needs.test-image-size.result == 'success')) }}
    environment: dev
    
    steps:
      - name: Download Docker Image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker Image
        run: docker load < /tmp/docker-image.tar.gz

      - name: Validate Docker Hub Credentials
        run: |
          [ -z "${{ secrets.DOCKERHUB_USERNAME }}" ] && { echo "‚ùå DOCKERHUB_USERNAME not set"; exit 1; }
          [ -z "${{ secrets.DOCKERHUB_TOKEN }}" ] && { echo "‚ùå DOCKERHUB_TOKEN not set"; exit 1; }
          echo "‚úÖ Credentials configured"

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag Images for Docker Hub
        run: |
          VERSION_TAG="${{ needs.build-image.outputs.image_tag }}"
          LOCAL_IMAGE_NAME="${{ needs.build-image.outputs.local_image_name }}"
          DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
          
          # Construct full image name
          FULL_IMAGE_NAME="$DOCKERHUB_USER/$LOCAL_IMAGE_NAME"
          
          # Verify local image exists
          if ! docker image inspect $LOCAL_IMAGE_NAME:$VERSION_TAG > /dev/null 2>&1; then
            echo "‚ùå ERROR: Local image $LOCAL_IMAGE_NAME:$VERSION_TAG not found!"
            docker images
            exit 1
          fi
          
          # Tag with version
          docker tag $LOCAL_IMAGE_NAME:$VERSION_TAG $FULL_IMAGE_NAME:$VERSION_TAG
          echo "‚úÖ Tagged: $FULL_IMAGE_NAME:$VERSION_TAG"
          
          # Tag as latest
          docker tag $LOCAL_IMAGE_NAME:$VERSION_TAG $FULL_IMAGE_NAME:latest
          echo "‚úÖ Tagged: $FULL_IMAGE_NAME:latest"

      - name: Check Image Test Results
        run: |
          echo "Image tests: Vulnerabilities=${{ needs.test-image-vulnerabilities.result }} Health=${{ needs.test-image-health.result }}"
          echo "Startup Test: ${{ needs.test-image-startup.result }}"
          echo "Size Test: ${{ needs.test-image-size.result }}"
          echo "Ports Test: ${{ needs.test-image-ports.result }}"
          echo "Env Vars Test: ${{ needs.test-image-env-vars.result }}"
          echo "Security Test: ${{ needs.test-image-security.result }}"
          echo "Shutdown Test: ${{ needs.test-image-shutdown.result }}"
          echo "Layers Test: ${{ needs.test-image-layers.result }}"
          echo "Push on failure: ${{ needs.setup.outputs.push_on_test_failure }}"
          
          if [ "${{ needs.setup.outputs.push_on_test_failure }}" = "yes" ]; then
            echo "‚ö†Ô∏è Pushing image despite test failures (push_on_test_failure=yes)"
          else
            echo "‚úÖ All image tests passed, proceeding with push"
          fi

      - name: Push Docker Image to Docker Hub
        run: |
          VERSION_TAG="${{ needs.build-image.outputs.image_tag }}"
          LOCAL_IMAGE_NAME="${{ needs.build-image.outputs.local_image_name }}"
          DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
          FULL_IMAGE_NAME="$DOCKERHUB_USER/$LOCAL_IMAGE_NAME"
          
          # Push version tag
          docker push $FULL_IMAGE_NAME:$VERSION_TAG
          echo "‚úÖ Pushed: $FULL_IMAGE_NAME:$VERSION_TAG"
          
          # Always push latest tag
          docker push $FULL_IMAGE_NAME:latest
          echo "‚úÖ Pushed: $FULL_IMAGE_NAME:latest"


      - name: Cleanup Old Docker Hub Images
        continue-on-error: true
        run: |
          DOCKERHUB_USER="${{ secrets.DOCKERHUB_USERNAME }}"
          DOCKERHUB_TOKEN="${{ secrets.DOCKERHUB_TOKEN }}"
          LOCAL_IMAGE_NAME="${{ needs.build-image.outputs.local_image_name }}"
          REPO_NAME="$DOCKERHUB_USER/$LOCAL_IMAGE_NAME"
          
          echo "Cleaning up old images from: $REPO_NAME"
          
          # Get JWT token for Docker Hub API
          TOKEN=$(curl -s -H "Content-Type: application/json" \
            -X POST \
            -d "{\"username\": \"$DOCKERHUB_USER\", \"password\": \"$DOCKERHUB_TOKEN\"}" \
            https://hub.docker.com/v2/users/login/ | jq -r .token)
          
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "‚ö†Ô∏è Could not authenticate with Docker Hub API"
            echo "Skipping cleanup (images will remain)"
            exit 0
          fi
          
          # Get all tags sorted by last updated (excluding 'latest')
          TAGS=$(curl -s -H "Authorization: JWT $TOKEN" \
            "https://hub.docker.com/v2/repositories/$REPO_NAME/tags/?page_size=100" \
            | jq -r '.results | sort_by(.last_updated) | reverse | .[].name' \
            | grep -v '^latest$')
          
          # Count tags
          TAG_COUNT=$(echo "$TAGS" | wc -l)
          echo "Found $TAG_COUNT version tags (excluding 'latest')"
          
          # Keep only last 5, delete the rest
          if [ $TAG_COUNT -gt 5 ]; then
            TAGS_TO_DELETE=$(echo "$TAGS" | tail -n +6)
            DELETE_COUNT=$(echo "$TAGS_TO_DELETE" | wc -l)
            
            echo "Deleting $DELETE_COUNT old images..."
            
            for TAG in $TAGS_TO_DELETE; do
              echo "Deleting tag: $TAG"
              curl -s -X DELETE \
                -H "Authorization: JWT $TOKEN" \
                "https://hub.docker.com/v2/repositories/$REPO_NAME/tags/$TAG/" > /dev/null
              
              if [ $? -eq 0 ]; then
                echo "  ‚úÖ Deleted: $REPO_NAME:$TAG"
              else
                echo "  ‚ö†Ô∏è Failed to delete: $REPO_NAME:$TAG"
              fi
            done
            
            echo "‚úÖ Cleanup complete: Deleted $DELETE_COUNT old images"
          else
            echo "‚úÖ No cleanup needed: Only $TAG_COUNT images (keeping last 5)"
          fi


  # ============================================
  # CLEANUP ARTIFACTS (After Push)
  # ============================================

  cleanup-artifacts:
    name: Cleanup Temporary Artifacts
    runs-on: ubuntu-latest
    needs: [push-image]
    if: ${{ always() && needs.push-image.result != 'skipped' }}
    
    steps:
      - name: Delete Docker Image Artifact
        uses: geekyeggo/delete-artifact@v5
        with:
          name: docker-image
          failOnError: false
      
      - name: Cleanup Summary
        run: |
          echo "‚úÖ Artifact deleted from GitHub storage"
          echo "Push: ${{ needs.push-image.result }}"
          echo "This frees up storage space and reduces costs"

